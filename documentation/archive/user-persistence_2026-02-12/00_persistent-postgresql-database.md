# Phase 0: Persistent PostgreSQL Database Setup

## PR Title
feat: Add PostgreSQL support with Alembic migrations for production deployment

## Risk Level / Estimated Effort
- **Risk Level**: Medium -- touches database initialization, configuration, and deployment. However, there is no existing data to migrate (clean slate), which reduces risk significantly.
- **Estimated Effort**: 3-5 hours for an experienced developer, 6-8 hours for a junior engineer.

## Files Created / Modified / Deleted

### Files Modified
| File | Change Summary |
|------|---------------|
| `requirements/base.txt` | Add `psycopg2-binary` PostgreSQL driver |
| `requirements/prod.txt` | Add `psycopg2` (compiled driver for production) |
| `config.py` | Fix `DATABASE_URL` handling for PostgreSQL (Neon/Railway `postgres://` prefix fix), add SSL and pool config |
| `shuffify/__init__.py` | Replace `db.create_all()` with `flask db upgrade` for production; keep `db.create_all()` for testing fallback |
| `shuffify/routes/core.py` | Enhance `/health` endpoint with database connectivity check |
| `shuffify/models/db.py` | Update module docstring (SQLite reference), no schema changes needed |
| `.env.example` | Add `DATABASE_URL` examples for Neon and Railway |
| `Dockerfile` | Install `libpq-dev` system dependency for psycopg2, update HEALTHCHECK, add `--preload` to gunicorn |
| `docker-compose.yml` | Add optional PostgreSQL service for local development |
| `.gitignore` | Add `*.db` to gitignore (SQLite files should not be tracked) |
| `CHANGELOG.md` | Add Phase 0 entries under `[Unreleased]` |
| `CLAUDE.md` | Update database references from SQLite to PostgreSQL |

### Files Created
| File | Purpose |
|------|---------|
| `migrations/` | Alembic migrations directory (generated by `flask db init`) |
| `migrations/env.py` | Alembic environment config (generated, then customized) |
| `migrations/alembic.ini` | Alembic configuration (generated) |
| `migrations/versions/xxxx_initial_schema.py` | Initial migration capturing all 5 existing models (generated by `flask db migrate`) |
| `tests/test_health_db.py` | Tests for the enhanced health check endpoint |

### Files Deleted
None.

## Context

Shuffify currently uses SQLite for all database operations. SQLite is adequate for development but insufficient for production deployment on Neon and Railway (both managed PostgreSQL providers). This phase establishes PostgreSQL as the production database while preserving SQLite as a local development fallback.

Key motivations:
1. **Neon and Railway both require PostgreSQL** -- the user explicitly targets these platforms.
2. **Alembic migrations are essential** before adding any new models in Phases 1-6. Without migrations, schema changes require manual intervention or destructive `db.create_all()` calls.
3. **`db.create_all()` in production is dangerous** -- it cannot alter existing tables, only create missing ones. Alembic handles both creation and alteration.
4. **The `db.JSON` column type** works differently in SQLite (stored as text) vs PostgreSQL (native JSONB). The current models use `db.JSON` for `source_playlist_ids` and `algorithm_params`. SQLAlchemy handles this transparently, but it is important to verify.

## Dependencies

### Prerequisites (must be true before starting)
- Flask-Migrate is already in `requirements/base.txt`
- Flask-Migrate is already initialized in `shuffify/__init__.py` (`_migrate = Migrate(app, db)`)
- No `migrations/` directory exists yet
- No production data exists (clean slate -- confirmed by user)

### What This Unlocks
- All subsequent phases (1-6) can use `flask db migrate` / `flask db upgrade` for schema changes
- Production deployment to Neon and Railway with proper connection pooling
- Database health monitoring via enhanced `/health` endpoint

## Detailed Implementation Plan

### Step 1: Add PostgreSQL Driver to Requirements

**File**: `requirements/base.txt`

**Current content (line 13)**:
```
Flask-Migrate>=4.0.0
```

**Add after line 13**:
```
psycopg2-binary>=2.9.9
```

**File**: `requirements/prod.txt`

**Current content**:
```
-r base.txt

# Production
sentry-sdk==1.45.1
```

**Change to**:
```
-r base.txt

# Production
sentry-sdk==1.45.1
psycopg2>=2.9.9
```

**Rationale**: `psycopg2-binary` is a pre-compiled wheel that works everywhere without build dependencies -- perfect for development and CI. `psycopg2` (non-binary) is the recommended production driver, compiled from source against the system `libpq` for maximum compatibility and performance. In production Docker builds, the Dockerfile installs `libpq-dev` so `psycopg2` can compile.

**Install after modifying**:
```bash
source venv/bin/activate && pip install -r requirements/dev.txt
```

### Step 2: Update Configuration for PostgreSQL

**File**: `config.py`

Three issues to address:
- **Issue A**: Neon and Railway provide `DATABASE_URL` with `postgres://` prefix, but SQLAlchemy 2.x requires `postgresql://`
- **Issue B**: Neon requires SSL connections (`sslmode=require`)
- **Issue C**: Connection pooling for managed PostgreSQL

**Add a module-level helper function after `load_dotenv()`**:

```python
def _resolve_database_url(fallback: str) -> str:
    """
    Resolve DATABASE_URL with PostgreSQL compatibility fixes.

    Neon and Railway provide DATABASE_URL with the `postgres://` scheme,
    but SQLAlchemy 2.x requires `postgresql://`.  This function
    transparently rewrites the prefix.

    Args:
        fallback: Default database URL if DATABASE_URL env var is not set.

    Returns:
        Resolved database URL string.
    """
    url = os.getenv('DATABASE_URL', fallback)
    if url and url.startswith('postgres://'):
        url = url.replace('postgres://', 'postgresql://', 1)
    return url
```

**In `Config` base class**, replace lines 43-46:
```python
    # Database configuration
    SQLALCHEMY_DATABASE_URI = _resolve_database_url('sqlite:///shuffify.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

**In `ProdConfig`**, replace lines 82-85:
```python
    # Production database - PostgreSQL via Neon or Railway
    SQLALCHEMY_DATABASE_URI = _resolve_database_url('sqlite:///shuffify.db')

    # PostgreSQL engine options: connection pooling and SSL for managed providers
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_size': 5,
        'pool_recycle': 300,
        'pool_pre_ping': True,
        'connect_args': (
            {'sslmode': 'require'}
            if os.getenv('DATABASE_URL', '').startswith('postgres')
            else {}
        ),
    }
```

**In `DevConfig`**, replace lines 100-102:
```python
    # Development database - PostgreSQL if DATABASE_URL is set, else SQLite
    SQLALCHEMY_DATABASE_URI = _resolve_database_url('sqlite:///shuffify_dev.db')
```

### Step 3: Update App Factory -- Replace `db.create_all()` with Migration-Aware Initialization

**File**: `shuffify/__init__.py`

**BEFORE** (lines 180-203):
```python
    # Initialize SQLAlchemy database
    try:
        from shuffify.models.db import db

        db.init_app(app)

        global _migrate
        _migrate = Migrate(app, db)

        # Create tables if they don't exist (development convenience)
        # In production, use Flask-Migrate/Alembic for schema changes
        with app.app_context():
            db.create_all()

        logger.info(
            "SQLAlchemy database initialized: %s",
            app.config.get("SQLALCHEMY_DATABASE_URI", "not set"),
        )
    except Exception as e:
        logger.warning(
            "Database initialization failed: %s. "
            "Persistence features will be unavailable.",
            e,
        )
```

**AFTER**:
```python
    # Initialize SQLAlchemy database
    try:
        from shuffify.models.db import db

        db.init_app(app)

        global _migrate
        _migrate = Migrate(app, db)

        with app.app_context():
            if app.config.get("TESTING"):
                # Tests use in-memory SQLite -- create tables directly
                db.create_all()
            else:
                # Development and production: use Alembic migrations.
                # In development without migrations dir, fall back to
                # db.create_all() for convenience.
                import os
                migrations_dir = os.path.join(
                    os.path.dirname(os.path.dirname(__file__)),
                    'migrations'
                )
                if os.path.isdir(migrations_dir):
                    from flask_migrate import upgrade
                    upgrade()
                else:
                    logger.warning(
                        "No migrations/ directory found. "
                        "Using db.create_all() as fallback. "
                        "Run 'flask db init && flask db migrate' "
                        "to set up Alembic migrations."
                    )
                    db.create_all()

        logger.info(
            "SQLAlchemy database initialized: %s",
            app.config.get("SQLALCHEMY_DATABASE_URI", "not set"),
        )
    except Exception as e:
        logger.warning(
            "Database initialization failed: %s. "
            "Persistence features will be unavailable.",
            e,
        )
```

**Key points**:
- `TESTING` config triggers `db.create_all()` -- preserves all 770 existing tests using in-memory SQLite.
- Non-testing environments check for `migrations/` directory. If it exists, run `flask db upgrade` programmatically.
- If `migrations/` does not exist, fall back to `db.create_all()` with a warning.

**Also add `is_db_available()` function** to `shuffify/__init__.py` (used by health endpoint):

```python
def is_db_available() -> bool:
    """Check if the database is reachable."""
    try:
        from shuffify.models.db import db
        db.session.execute(db.text("SELECT 1"))
        return True
    except Exception:
        return False
```

### Step 4: Initialize Alembic Migrations

**Commands to run** (in order):
```bash
cd /Users/chris/Projects/shuffify
source venv/bin/activate
export FLASK_APP=run.py
export FLASK_ENV=development

# Step 4a: Initialize Alembic
flask db init

# Step 4b: Verify migrations/env.py has correct target_metadata:
#   target_metadata = current_app.extensions['migrate'].db.metadata
# (This is correct and requires no changes)

# Step 4c: Generate the initial migration
flask db migrate -m "Initial schema: users, workshop_sessions, upstream_sources, schedules, job_executions"

# Step 4d: Review the generated file in migrations/versions/
# Verify all 5 tables, columns, indexes, and foreign keys are present

# Step 4e: Test the migration against SQLite
rm -f instance/shuffify_dev.db
flask db upgrade
```

### Step 5: Enhance the Health Check Endpoint

**File**: `shuffify/routes/core.py`

**BEFORE** (lines 99-110):
```python
@main.route("/health")
def health():
    """Health check endpoint for Docker and monitoring."""
    return (
        jsonify({
            "status": "healthy",
            "timestamp": datetime.now(
                timezone.utc
            ).isoformat(),
        }),
        200,
    )
```

**AFTER**:
```python
@main.route("/health")
def health():
    """Health check endpoint for Docker and monitoring."""
    from shuffify import is_db_available

    db_healthy = is_db_available()
    overall_status = "healthy" if db_healthy else "degraded"

    return (
        jsonify({
            "status": overall_status,
            "timestamp": datetime.now(
                timezone.utc
            ).isoformat(),
            "checks": {
                "database": "ok" if db_healthy else "unavailable",
            },
        }),
        200,
    )
```

**Design decision**: Returns `200` even when degraded -- a `503` would cause Docker to restart the container in a loop during temporary database outages.

### Step 6: Update `.env.example`

**File**: `.env.example`

**BEFORE** (lines 23-25):
```
# --- Database ---
# SQLite is used by default. Override for PostgreSQL/MySQL in production.
# SQLALCHEMY_DATABASE_URI=sqlite:///shuffify.db
```

**AFTER**:
```
# --- Database ---
# SQLite is used by default for local development.
# For production, set DATABASE_URL to your PostgreSQL connection string.
#
# Neon (pooled connection):
# DATABASE_URL=postgres://user:pass@ep-xxx-yyy-zzz.us-east-2.aws.neon.tech/neondb?sslmode=require
#
# Railway:
# DATABASE_URL=postgresql://postgres:pass@host.railway.app:5432/railway
#
# Local PostgreSQL:
# DATABASE_URL=postgresql://localhost:5432/shuffify_dev
#
# Note: Both postgres:// and postgresql:// prefixes are accepted.
# The app automatically converts postgres:// to postgresql:// for SQLAlchemy.
# DATABASE_URL=
```

### Step 7: Update Dockerfile

**File**: `Dockerfile`

Add `libpq-dev` to system dependencies:
```dockerfile
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*
```

Update HEALTHCHECK:
```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1
```

Add `--preload` to gunicorn CMD:
```dockerfile
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--preload", "run:app"]
```

The `--preload` flag loads the app before forking workers, so migrations run once in the master process.

### Step 8: Update `docker-compose.yml` with PostgreSQL Service

**AFTER**:
```yaml
services:
  app:
    build: .
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - .:/app
      - flask_session:/app/.flask_session

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: shuffify_dev
      POSTGRES_USER: shuffify
      POSTGRES_PASSWORD: shuffify_dev_password
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U shuffify -d shuffify_dev"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  flask_session:
  pgdata:
```

Set `DATABASE_URL=postgresql://shuffify:shuffify_dev_password@db:5432/shuffify_dev` in `.env` for docker-compose.

### Step 9: Update `.gitignore`

Add after `instance/`:
```
*.db
```

### Step 10: Update Model Docstring

**File**: `shuffify/models/db.py`

**BEFORE** (lines 1-6):
```python
"""
SQLAlchemy database models for Shuffify.

Defines the User, WorkshopSession, and UpstreamSource models
for persistent storage in SQLite.
"""
```

**AFTER**:
```python
"""
SQLAlchemy database models for Shuffify.

Defines the User, WorkshopSession, UpstreamSource, Schedule, and
JobExecution models for persistent storage. Supports PostgreSQL
(production) and SQLite (development/testing).
"""
```

### Step 11: Verify Models Are PostgreSQL-Compatible

| Feature | SQLite | PostgreSQL | Action |
|---------|--------|-----------|--------|
| `db.JSON` | Stored as TEXT | Native JSONB | None -- SQLAlchemy handles |
| `db.DateTime` with lambdas | Works | Works | None |
| `db.String(255)` | No length enforcement | Enforces length | None -- 255 is generous |
| `db.Boolean` | INTEGER (0/1) | Native BOOLEAN | None -- SQLAlchemy handles |
| `db.Index` composites | Works | Works | None |
| `StrEnum` defaults | Stored as string | Stored as string | None |

**Verdict**: No model changes required. All types are compatible via SQLAlchemy's dialect abstraction.

## Test Plan

### Existing Tests -- Must Not Break

The 770 existing tests use in-memory SQLite via `conftest.py` fixtures. The `TESTING = True` check in the app factory routes to `db.create_all()`, completely bypassing Alembic.

```bash
source venv/bin/activate && pytest tests/ -v
```

All 770 tests must pass with zero failures.

### New Tests to Add

**File**: `tests/test_health_db.py`

```python
"""
Tests for enhanced health check endpoint with database status.
"""

import pytest
from unittest.mock import patch


class TestHealthEndpoint:
    """Tests for the /health endpoint."""

    def test_health_returns_200(self, client):
        """Health endpoint should return 200."""
        response = client.get("/health")
        assert response.status_code == 200

    def test_health_includes_database_check(self, client):
        """Health response should include database check."""
        response = client.get("/health")
        data = response.get_json()
        assert "checks" in data
        assert "database" in data["checks"]

    def test_health_database_ok_when_available(self, client):
        """Database check should be 'ok' when DB is available."""
        response = client.get("/health")
        data = response.get_json()
        assert data["status"] == "healthy"
        assert data["checks"]["database"] == "ok"

    def test_health_database_unavailable(self, client):
        """Database check should report 'unavailable' on failure."""
        with patch(
            "shuffify.routes.core.is_db_available",
            return_value=False,
        ):
            response = client.get("/health")
            data = response.get_json()
            assert data["status"] == "degraded"
            assert data["checks"]["database"] == "unavailable"

    def test_health_includes_timestamp(self, client):
        """Health response should include ISO timestamp."""
        response = client.get("/health")
        data = response.get_json()
        assert "timestamp" in data
        assert "T" in data["timestamp"]
```

### Manual Verification Steps

```bash
# 1. Lint
flake8 shuffify/

# 2. All tests pass
pytest tests/ -v

# 3. Verify migration was generated
ls migrations/versions/

# 4. Test migration from scratch
rm -f instance/shuffify_dev.db
FLASK_APP=run.py flask db upgrade

# 5. Verify postgres:// conversion
python -c "
import os
os.environ['DATABASE_URL'] = 'postgres://user:pass@host/db'
from config import _resolve_database_url
result = _resolve_database_url('sqlite:///fallback.db')
assert result == 'postgresql://user:pass@host/db'
print('postgres:// -> postgresql:// conversion works')
"

# 6. Pre-push check
flake8 shuffify/ && pytest tests/ -v && echo 'Ready to push!'
```

## Documentation Updates

### CHANGELOG.md

Add under `## [Unreleased]`:

```markdown
### Added
- **PostgreSQL Support** - Production database support for Neon and Railway
  - Added `psycopg2-binary` (development) and `psycopg2` (production) drivers
  - Automatic `postgres://` to `postgresql://` URL conversion for managed providers
  - SSL and connection pooling configuration for Neon/Railway
- **Alembic Migrations** - Database schema management via Flask-Migrate
  - Initial migration capturing all 5 tables
  - Automatic migration execution on app startup (non-test environments)
  - `db.create_all()` preserved for test fixtures using in-memory SQLite
- **Database Health Check** - Enhanced `/health` endpoint reports database connectivity
- **Docker PostgreSQL** - Added PostgreSQL service to `docker-compose.yml`

### Changed
- **Database Config** - `config.py` uses `_resolve_database_url()` helper for DATABASE_URL resolution
- **App Factory** - Uses Alembic `upgrade()` instead of `db.create_all()` for non-test environments
- **Dockerfile** - Added `libpq-dev`, `--preload` for gunicorn, updated HEALTHCHECK to `/health`
```

### CLAUDE.md Updates
- Update Tech Stack: `**Database**: SQLAlchemy + PostgreSQL (production) / SQLite (development/testing)`
- Update Configuration section with DATABASE_URL documentation
- Add `migrations/versions/` to Key Files table

## Edge Cases & Error Scenarios

1. **`postgres://` prefix** -- Neon/Railway provide this but SQLAlchemy 2.x requires `postgresql://`. Handled by `_resolve_database_url()`.
2. **Database unavailable on startup** -- Existing try/except catches failures; app starts degraded. Health reports `"degraded"`.
3. **SSL required by Neon** -- `ProdConfig.SQLALCHEMY_ENGINE_OPTIONS` includes `sslmode=require` when DATABASE_URL starts with `postgres`.
4. **Multiple gunicorn workers** -- `--preload` ensures migrations run once in master process.
5. **Tests still using SQLite** -- `TESTING = True` check bypasses Alembic entirely.
6. **`db.JSON` differences** -- SQLAlchemy abstracts SQLite TEXT vs PostgreSQL JSONB. No code changes needed.
7. **Neon PgBouncer** -- `pool_pre_ping=True` and `pool_recycle=300` handle stale connections.
8. **Missing migrations directory** -- App falls back to `db.create_all()` with warning log.

## Verification Checklist

- [ ] `pip install -r requirements/dev.txt` succeeds
- [ ] `flake8 shuffify/` reports 0 errors
- [ ] `pytest tests/ -v` -- all 770+ tests pass
- [ ] `migrations/` directory exists with initial migration
- [ ] `flask db upgrade` creates all 5 tables plus `alembic_version`
- [ ] `flask db downgrade` drops back to empty
- [ ] `postgres://` URLs correctly converted to `postgresql://`
- [ ] `DATABASE_URL` unset falls back to SQLite
- [ ] `/health` reports database status correctly
- [ ] Docker build succeeds
- [ ] `.env.example` has DATABASE_URL examples
- [ ] CHANGELOG.md updated
- [ ] No `.db` files committed

## What NOT To Do

1. **Do NOT remove SQLite support entirely.** It remains the default for local dev and all tests.
2. **Do NOT use `db.create_all()` in production.** It cannot handle schema changes.
3. **Do NOT hardcode PostgreSQL connection strings.** Use `DATABASE_URL` env var.
4. **Do NOT add `sslmode=require` to DevConfig.** Local PostgreSQL may not have SSL.
5. **Do NOT modify test fixtures to use Alembic.** Tests must use `db.create_all()` with in-memory SQLite.
6. **Do NOT add compiled `psycopg2` to `base.txt`.** Binary version is sufficient for dev/CI.
7. **Do NOT return 503 from health when DB is down.** Docker would restart in a loop.
8. **Do NOT add `migrations/` to `.gitignore`.** Migration files MUST be version controlled.
9. **Do NOT edit committed migrations.** Create new migrations for schema changes.
10. **Do NOT run `flask db upgrade` as separate Docker CMD step.** Programmatic `upgrade()` with `--preload` is cleaner.
